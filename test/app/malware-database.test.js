import assert from 'node:assert/strict'
import { mkdir, unlink, writeFile } from 'node:fs/promises'
import { test } from 'node:test'
import Fastify from 'fastify'
import blacklistManager from '../../app/plugins/blacklist.js'
import malwareDatabaseManager from '../../app/plugins/malware-database.js'

test('Malware database manager loads and checks malware correctly', async () => {
  // Create test malware database
  const testMalwareData = [
    {
      package_name: 'malicious-package',
      version: '1.0.0',
      reason: 'MALWARE',
    },
    {
      package_name: 'evil-lib',
      version: '*',
      reason: 'MALWARE',
    },
    {
      package_name: 'suspicious-tool',
      version: '2.1.0',
      reason: 'TELEMETRY',
    },
  ]

  await mkdir('./malware-list.aikido.dev', { recursive: true })
  await writeFile('./malware-list.aikido.dev/malware_predictions.json', JSON.stringify(testMalwareData, null, 2))

  try {
    const fastify = Fastify({ logger: false })
    await fastify.register(malwareDatabaseManager, {
      enableScheduledUpdates: false, // Disable for testing
    })

    const { isMalware, getStats } = fastify.malwareDatabaseManager

    // Test exact version match
    const maliciousResult = isMalware('malicious-package', '1.0.0')
    assert.equal(maliciousResult.blocked, true)
    assert.equal(maliciousResult.reason, 'MALWARE')
    assert.equal(maliciousResult.type, 'malware')
    assert.equal(maliciousResult.source, 'aikido')

    // Test wildcard version match
    const evilResult = isMalware('evil-lib', '5.0.0')
    assert.equal(evilResult.blocked, true)
    assert.equal(evilResult.reason, 'MALWARE')

    // Test different reason types
    const telemetryResult = isMalware('suspicious-tool', '2.1.0')
    assert.equal(telemetryResult.blocked, true)
    assert.equal(telemetryResult.reason, 'TELEMETRY')

    // Test no match cases
    const safeResult = isMalware('safe-package', '1.0.0')
    assert.equal(safeResult.blocked, false)

    const wrongVersionResult = isMalware('malicious-package', '2.0.0')
    assert.equal(wrongVersionResult.blocked, false)

    // Test stats
    const stats = getStats()
    assert.equal(stats.entries, 3)

    await fastify.close()
  }
  finally {
    await unlink('./malware-list.aikido.dev/malware_predictions.json').catch(() => {})
    await unlink('./malware-list.aikido.dev/.etag').catch(() => {})
  }
})

test('Malware database integration with blacklist manager', async () => {
  // Create test malware database
  const testMalwareData = [
    {
      package_name: 'malware-from-aikido',
      version: '1.0.0',
      reason: 'MALWARE',
    },
  ]

  // Create test blacklist
  const testBlacklist = `packages:
  - name: malware-from-blacklist
    reason: Known malware from local blacklist

patterns:
  - pattern: ".*evil.*"
    reason: Evil pattern`

  await mkdir('./malware-list.aikido.dev', { recursive: true })
  await writeFile('./malware-list.aikido.dev/malware_predictions.json', JSON.stringify(testMalwareData, null, 2))
  const testBlacklistPath = `./test-blacklist-${Date.now()}.yml`
  await writeFile(testBlacklistPath, testBlacklist)

  try {
    const fastify = Fastify({ logger: false })

    // Register malware database manager first
    await fastify.register(malwareDatabaseManager, {
      enableScheduledUpdates: false,
    })

    // Then register blacklist manager
    await fastify.register(blacklistManager, {
      BLACKLIST_PATH: testBlacklistPath,
    })

    const { isBlacklisted } = fastify.blacklistManager

    // Test malware database takes precedence (checked first)
    const aikidoResult = isBlacklisted('malware-from-aikido', '1.0.0')
    assert.equal(aikidoResult.blocked, true)
    assert.equal(aikidoResult.reason, 'MALWARE')
    assert.equal(aikidoResult.type, 'malware')
    assert.equal(aikidoResult.source, 'aikido')

    // Test local blacklist still works
    const localResult = isBlacklisted('malware-from-blacklist')
    assert.equal(localResult.blocked, true)
    assert.equal(localResult.reason, 'Known malware from local blacklist')
    assert.equal(localResult.type, 'package')

    // Test pattern matching still works
    const patternResult = isBlacklisted('evil-package')
    assert.equal(patternResult.blocked, true)
    assert.equal(patternResult.reason, 'Evil pattern')
    assert.equal(patternResult.type, 'pattern')

    // Test safe package passes both checks
    const safeResult = isBlacklisted('safe-package', '1.0.0')
    assert.equal(safeResult.blocked, false)

    await fastify.close()
  }
  finally {
    await unlink('./malware-list.aikido.dev/malware_predictions.json').catch(() => {})
    await unlink('./malware-list.aikido.dev/.etag').catch(() => {})
    await unlink(testBlacklistPath).catch(() => {})
  }
})

test('Malware database handles missing files gracefully', async () => {
  // Ensure no malware database exists
  await unlink('./malware-list.aikido.dev/malware_predictions.json').catch(() => {})

  const fastify = Fastify({ logger: false })
  await fastify.register(malwareDatabaseManager, {
    enableScheduledUpdates: false,
    allowRemoteFetch: false, // Disable remote fetch for testing
  })

  const { isMalware, getStats } = fastify.malwareDatabaseManager

  // Should not block anything when database is empty
  const result = isMalware('any-package', '1.0.0')
  assert.equal(result.blocked, false)

  // Stats should show 0 entries
  const stats = getStats()
  assert.equal(stats.entries, 0)

  await fastify.close()
})
