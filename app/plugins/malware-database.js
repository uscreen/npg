import fs from 'node:fs/promises'
import path from 'node:path'
import process from 'node:process'
import fp from 'fastify-plugin'
import { request } from 'undici'

const MALWARE_URL = 'https://malware-list.aikido.dev/malware_predictions.json'

export default fp(
  async (fastify, opts) => {
    const baseDir = opts.MALWARE_LIST_DIR || process.cwd()
    const dbPath = path.join(baseDir, 'malware-list.aikido.dev', 'malware_predictions.json')
    const etagPath = path.join(baseDir, 'malware-list.aikido.dev', '.etag')

    let malwareList = []
    const malwareMap = new Map() // Map for O(1) lookups: "package:version" -> entry
    const wildcardPackages = new Map() // Map for packages with wildcard versions: package -> entry
    let updateTimer = null

    /**
     * Simple file operations
     */
    const readFile = async (filePath) => {
      try {
        return await fs.readFile(filePath, 'utf8')
      }
      catch {
        return null
      }
    }

    const writeFile = async (filePath, content) => {
      await fs.mkdir(path.dirname(filePath), { recursive: true })
      await fs.writeFile(filePath, content)
    }

    /**
     * Load local malware database
     */
    const loadLocal = async () => {
      const data = await readFile(dbPath)
      return data ? JSON.parse(data) : []
    }

    /**
     * Fetch from remote with timeout
     */
    const fetchRemote = async () => {
      const response = await request(MALWARE_URL, {
        headersTimeout: 10000, // 10s headers timeout
        bodyTimeout: 30000, // 30s body timeout
      })
      if (response.statusCode !== 200) {
        throw new Error(`HTTP ${response.statusCode}`)
      }

      const data = await response.body.json()
      const etag = response.headers.etag

      return { data, etag }
    }

    /**
     * Build lookup maps from malware list for O(1) performance
     */
    const buildMalwareMaps = (data) => {
      malwareMap.clear()
      wildcardPackages.clear()

      for (const entry of data) {
        const { package_name, version } = entry

        if (version === '*') {
          // Store wildcard packages with full entry
          wildcardPackages.set(package_name, entry)
        }
        else {
          // Store specific version entries
          const key = `${package_name}:${version}`
          malwareMap.set(key, entry)
        }
      }

      fastify.log.debug(`Built malware maps: ${malwareMap.size} versioned entries, ${wildcardPackages.size} wildcard packages`)
    }

    /**
     * Check if update needed
     */
    const needsUpdate = async () => {
      try {
        const response = await request(MALWARE_URL, {
          method: 'HEAD',
          headersTimeout: 5000, // 5s timeout for HEAD request
        })
        const remoteEtag = response.headers.etag
        const localEtag = await readFile(etagPath)

        return remoteEtag && remoteEtag !== localEtag?.trim()
      }
      catch {
        return false
      }
    }

    /**
     * Update database
     */
    const updateDatabase = async () => {
      if (!await needsUpdate()) {
        fastify.log.debug('Malware database up to date')
        return false
      }

      try {
        fastify.log.info('Updating malware database...')
        const { data, etag } = await fetchRemote()

        await writeFile(dbPath, JSON.stringify(data, null, 2))
        if (etag)
          await writeFile(etagPath, etag)

        malwareList = data
        buildMalwareMaps(data)
        fastify.log.info(`Updated malware database: ${data.length} entries`)
        return true
      }
      catch (error) {
        fastify.log.error(`Failed to update malware database: ${error.message}`)
        return false
      }
    }

    /**
     * Load initial data
     */
    const initialize = async () => {
      malwareList = await loadLocal()

      if (malwareList.length === 0 && opts.ALLOW_REMOTE_FETCH !== false) {
        fastify.log.info('No local database, fetching from remote in background...')
        // Don't await - fetch in background to avoid blocking startup
        updateDatabase().catch((error) => {
          fastify.log.error(`Background malware database fetch failed: ${error.message}`)
        })
      }
      else if (malwareList.length > 0) {
        buildMalwareMaps(malwareList)
      }

      fastify.log.info(`Loaded malware database: ${malwareList.length} entries`)
    }

    /**
     * Check if package is malware using O(1) Map lookups
     */
    const isMalware = (packageName, version = null) => {
      // Check wildcard packages first (always blocked regardless of version)
      const wildcardEntry = wildcardPackages.get(packageName)
      if (wildcardEntry) {
        return {
          blocked: true,
          reason: wildcardEntry.reason || 'Package identified as malware (Aikido)',
          type: 'malware',
          source: 'aikido',
          version: wildcardEntry.version,
        }
      }

      // If no version provided, only wildcard entries would block (already checked above)
      if (!version) {
        return { blocked: false }
      }

      // Check specific version entry
      const versionKey = `${packageName}:${version}`
      const entry = malwareMap.get(versionKey)

      if (entry) {
        return {
          blocked: true,
          reason: entry.reason || 'Package identified as malware (Aikido)',
          type: 'malware',
          source: 'aikido',
          version: entry.version,
        }
      }

      return { blocked: false }
    }

    fastify.decorate('malwareDatabaseManager', {
      isMalware,
      forceUpdate: updateDatabase,
      getStats: () => ({ entries: malwareList.length }),
    })

    // Initialize immediately
    await initialize()

    // Setup scheduled updates
    if (opts.ENABLE_SCHEDULED_UPDATES !== false) {
      const interval = opts.UPDATE_INTERVAL || 6 * 60 * 60 * 1000 // 6 hours
      updateTimer = setInterval(updateDatabase, interval)
      fastify.log.info(`Scheduled malware database updates every ${interval / 1000 / 60 / 60}h`)
    }

    // Cleanup on close
    fastify.addHook('onClose', async () => {
      if (updateTimer)
        clearInterval(updateTimer)
    })

    // Schedule update after ready (non-blocking)
    fastify.ready(() => {
      // Don't await - run in background
      updateDatabase().catch((error) => {
        fastify.log.warn(`Background malware database update failed: ${error.message}`)
      })
    })
  },
  { name: 'malware-database-manager' },
)
